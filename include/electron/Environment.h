/**
 * @file
 * C++ wrapper functions for building electron environments
 * @copyright
 * Copyright (c) 2015-2022 Parasoft Corporation
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 *
 */

#ifndef __LibElectron_Environment_h__
#define __LibElectron_Environment_h__
#include "platform/types.h"
#include "error/Exception.h"
#include "fs/path.h"
#include <limits>
#include <functional>
#include <list>
#include <vector>
#include <set>
#include <string>
#include <sstream>
#include <utility>
#include <map>
#include <typeinfo>
#include <type_traits>
#include "debug/here.h"
#include "electron/Aliases.h"
#include "features/observer_ptr.h"
#include "features/dependent_false.h"
#include "features/type_traits.h"
#include <unordered_map>
#include "electron/ArgumentConstructor.h"

extern "C" {
    #include "clips.h"
    #include "miscfun.h"
    #include "factfile.h"
}

namespace Electron
{

// This will cause tons of symbols to be generated by the compiler but it is
// the cleanest
namespace ArgumentBits
{
constexpr auto Float = FLOAT_BIT;
constexpr auto Integer = INTEGER_BIT;
constexpr auto Symbol = SYMBOL_BIT;
constexpr auto String = STRING_BIT;
constexpr auto Multifield = MULTIFIELD_BIT;
constexpr auto ExternalAddress = EXTERNAL_ADDRESS_BIT;
constexpr auto FactAddress = FACT_ADDRESS_BIT;
constexpr auto InstanceAddress = INSTANCE_ADDRESS_BIT;
constexpr auto InstanceName = INSTANCE_NAME_BIT;
constexpr auto Void = VOID_BIT;
constexpr auto Boolean = BOOLEAN_BIT;
constexpr auto Number = NUMBER_BITS;
constexpr auto Lexeme = LEXEME_BITS;
constexpr auto Address = ADDRESS_BITS;
constexpr auto Instance = INSTANCE_BITS;
constexpr auto Singlefield = SINGLEFIELD_BITS;
constexpr auto Any = ANY_TYPE_BITS;
} // end namespace ArgumentBits

namespace Types
{
constexpr auto Float = FLOAT_TYPE;
constexpr auto Integer = INTEGER_TYPE;
constexpr auto Symbol = SYMBOL_TYPE;
constexpr auto String = STRING_TYPE;
constexpr auto Multifield = MULTIFIELD_TYPE;
constexpr auto ExternalAddress = EXTERNAL_ADDRESS_TYPE;
constexpr auto FactAddress = FACT_ADDRESS_TYPE;
constexpr auto InstanceAddress = INSTANCE_ADDRESS_TYPE;
constexpr auto InstanceName = INSTANCE_NAME_TYPE;
constexpr auto Void = VOID_TYPE;
} // end namespace Types

#define DefSingleTypeCheck(operation, compare) \
    template<typename T> \
    constexpr bool operation (T value) noexcept { \
        return value == Types:: compare; \
    } \
    inline bool operation ( TypeHeader* value ) noexcept { return value && operation (value -> type); } \
    inline bool operation ( Value* value ) noexcept { return value && operation (value->header); } \
    inline bool operation ( Value& value ) noexcept { return operation (value.header); } \
    inline bool operation ( UDFValue* value ) noexcept { return value && operation(value->header); } \
    inline bool operation ( UDFValue& value ) noexcept { return operation (value.header); }

DefSingleTypeCheck(isFloat, Float);
DefSingleTypeCheck(isMultifield, Multifield);
DefSingleTypeCheck(isSymbol, Symbol);
DefSingleTypeCheck(isString, String);
DefSingleTypeCheck(isInstanceName, InstanceName);
DefSingleTypeCheck(isInstanceAddress, InstanceAddress);
DefSingleTypeCheck(isExternalAddress, ExternalAddress);
DefSingleTypeCheck(isInteger, Integer);
#undef DefSingleTypeCheck

template<typename T>
constexpr bool isLexeme(T value) noexcept {
    return value == Types::Symbol || value == Types::String;
}
template<typename T>
constexpr bool usesLexemeField(T value) noexcept {
    return isLexeme(value) || value == Types::InstanceName;
}
template<typename T>
constexpr bool isInstance(T value) noexcept {
    return value == Types::InstanceName || value == Types::InstanceAddress;
}
template<typename T>
constexpr bool isNumber(T value) noexcept {
    return value == Types::Integer || value == Types::Float;
}
#define DefCustomTypeChecker(operation) \
    inline bool operation ( TypeHeader* value ) noexcept { return value && operation (value -> type); } \
    inline bool operation ( Value* value ) noexcept { return value && operation (value->header); } \
    inline bool operation ( Value& value ) noexcept { return operation (value.header); }
DefCustomTypeChecker(isInstance);
DefCustomTypeChecker(usesLexemeField);
DefCustomTypeChecker(isLexeme);
DefCustomTypeChecker(isNumber);
#undef DefCustomTypeChecker

/**
 * Convert a reference to a pointer, useful for building functions!
 * @tparam T The type of the thing to convert from reference to pointer
 * @param input The reference to convert!
 * @return The address of the thing the reference is referring to
 */
template<typename T>
T* reference(T& input) noexcept
{
    return &input;
}

class TreatLexemeAsString { };
class TreatLexemeAsSymbol { };
class TreatLexemeAsInstanceName { };

class Environment;
/**
 * A special function building class that is useful when funcall is evaluating
 * arguments and it shouldn't be.
 */
class FunctionBuilder
{
public:
    using RawType = ::FunctionCallBuilder;
public:
    FunctionBuilder(Environment& env, size_t initialCapacity = 10);
    ~FunctionBuilder();
    void call(const std::string& name, Value* out);
    void reset();
    void add(Value* value);
    inline void add(Value& value) { add(&value); }
    void add(UDFValue* value);
    inline void add(UDFValue& value) { add(&value); }
    void add(const char* str);
    /**
     * Install a string into the function arguments
     * @param str The string to install
     */
    void add(const std::string& str) { add(str.c_str()); }


    /**
     * Install a path into the function arguments as a string
     * @param str The path to install
     */
    void add(const Neutron::Path& str) { add(str.string()); }

    void add(int64 value);
    void add(uint64 value);
    void add(int32 value);
    void add(uint32 value);
    void add(double value);
    void add(float value);
    /**
     * Add a boolean to the function arguments
     */
    void add(bool value);
    void add(Lexeme* value);
    inline void add(Lexeme& value) { add(&value); }
    void add(Integer* value);
    inline void add(Integer& value) { add(&value); }
    void add(Fact* value);
    inline void add(Fact& value) { add(&value); }
    void add(Multifield* value);
    inline void add(Multifield& value) { add(&value); }
    void add(ExternalAddress* value);
    inline void add(ExternalAddress& value) { add(&value); }
    void add(Instance* value);
    inline void add(Instance& value) { add(&value); }
    void add(const char* lex, TreatLexemeAsString);
    void add(const std::string& lex, TreatLexemeAsString);
    void add(const Neutron::Path& lex, TreatLexemeAsString);
    void add(const char* lex, TreatLexemeAsSymbol);
    void add(const std::string& lex, TreatLexemeAsSymbol);
    void add(const Neutron::Path& lex, TreatLexemeAsSymbol);
    void add(const char* lex, TreatLexemeAsInstanceName);
    void add(const std::string& lex, TreatLexemeAsInstanceName);
    void add(const Neutron::Path& lex, TreatLexemeAsInstanceName);
    template<typename Str, typename Tag>
    void add(const std::tuple<Str, Tag>& tup) noexcept
    {
        add(std::get<0>(tup), Tag{});
    }

    /**
     * Add an unknown type to the list of arguments
     * @tparam T the type to be inserted
     * @param value A pointer to a value of given type to insert
     */
    template<typename T>
    void add(T* value);

    /**
     * Flatten the contents of the std::list by adding individual elements
     * @param list the list which has the contents to add to the expression
     */
    template<typename T>
    void add(const std::list<T>& list)
    {
        for (auto const &element : list) {
            add(element);
        }
    }

    template<typename T>
    void add(const std::initializer_list<T>& list)
    {
        for (auto const &element : list) {
            add(element);
        }

    }

    template<typename T>
    void add(const std::vector<T>& list)
    {
        for (auto const &element : list) {
            add(element);
        }
    }

    template<typename ... Args>
    void addArguments(Args&& ... values)
    {
        // this causes infinite loops when dealing with mixed types so this version
        // has a different name.
        (add(std::forward<Args>(values)), ...);

    }

    using FunctionBuilderModifier = std::function<void(FunctionBuilder*)>;
    void add(FunctionBuilderModifier fn);

    /**
     * Return a function which operates on a begin and end iterator.
     */
    template<typename I>
    static FunctionBuilderModifier collection(I begin, I end)
    {
        return [begin, end](FunctionBuilder* fb) {
            for (I it = begin; it != end; ++it) {
                fb->add(*it);
            }
        };
    }

    /**
     * Return a function which operates on a container.
     */
    template<typename I>
    static FunctionBuilderModifier collection(const I& i)
    {
        return [&i](FunctionBuilder* fb) {
            for (auto it : i) {
                fb->add(it);
            }
        };
    }

    /**
     * Mark the given thing as a symbol by capturing it and returning it as a
     * std::function.
     * @param thingToConvertToSymbol The thing that we want to convert into a * symbol
     * @return a packed tuple which describes the thing plus the desire for it to be a Symbol
     */
    template<typename T>
    static auto symbol(T thingToConvertToSymbol)
    {
        return std::make_tuple(thingToConvertToSymbol, TreatLexemeAsSymbol{});
    }

    template<typename T>
    static auto instanceName(T thingToConvertToInstanceName)
    {
        return std::make_tuple(thingToConvertToInstanceName, TreatLexemeAsInstanceName{});
    }
    template<typename T>
    static FunctionBuilderModifier externalAddress(T* thingToWrapAsExternalAddress);


private:
    Environment& _env;
    RawType * _bldr;
};


template<typename T>
struct ExternalAddressCache
{
    public:
        ExternalAddressCache() = delete;
        ~ExternalAddressCache() = delete;
        ExternalAddressCache(const ExternalAddressCache&) = delete;
        ExternalAddressCache(ExternalAddressCache&&) = delete;
        static int getExternalAddressId(Environment& env);
        static void registerExternalAddressId(Environment& env, int result);
        static bool typeRegistered(Environment& env);
        static void deregister(Environment& env);
    private:
        static int getExternalAddressId(RawEnvironment* env);
        static void registerExternalAddressId(RawEnvironment* env, int result);
        static bool typeRegistered(RawEnvironment* env);
        static void deregister(RawEnvironment* env);
        static std::unordered_map<RawEnvironment*, int> _cache;
};
template<typename R, typename ... Args>
using EnvironmentFunction = std::function<R(Environment&, Args...)>;
using RouterQueryFunction = EnvironmentFunction<bool, const char*>;
using RouterWriteFunction = EnvironmentFunction<void, const char*, const char*>;
using RouterExitFunction = EnvironmentFunction<void, int>;
using RouterReadFunction = EnvironmentFunction<int, const char*>;
using RouterUnreadFunction = EnvironmentFunction<int, const char*, int>;
/**
 * A set of functions that can be plugged into CLIPS for execution purposes.
 */

namespace TypeToName
{
    template<typename T>
    constexpr bool hasSymbolicName() noexcept { return false; }

    template<typename T>
    std::string getSymbolicName() noexcept
    {
         static_assert(hasSymbolicName<T>(), "No specialization for type T");
         return "";
    }
}
#define DefWrapperSymbolicName(t, name) \
    namespace TypeToName  \
    { \
        template<> constexpr bool hasSymbolicName < t > () noexcept { return true; } \
        template<> std::string getSymbolicName< t > () noexcept { return name; } \
    }

/**
 * Unpack and print the given external address to the specified IO Router
 * @param env The raw CLIPS environment pointer
 * @param logicalName The IO Router name to print to
 * @param theValue The wrapped value to print out
 * @param func - The name of external address as registered
 */
void printExternalAddress(RawEnvironment* env, const std::string& logicalName, void* theValue, const std::string& func) noexcept;


/**
 * Cache and then return the text name associated with the given type.
 * @tparam T the type of the external address
 * @return A const char* of the internal std::string, this prevents the string from going out of scope and will always be defined.
 */
template<typename T>
const char* getSymbolicName() noexcept
{
    // this is safe because the string will remain constant through out the
    // entire lifetime of the program
    static bool init = true;
    static std::string func;
    if (init) {
        init = false;
        func = TypeToName::getSymbolicName<T>();
    }
    return func.c_str();
}

/**
 * A generic wrapper which is meant to make the act of printing external
 * addresses trivial.
 * @tparam T The type of the external address to print
 * @param env A raw environment pointer
 * @param logicalName The name of the IO Router to output to
 * @param theValue The value to print out safely wrapped as a void pointer
 */
template<typename T>
void printExternalAddress(RawEnvironment* env, const char* logicalName, void* theValue)
{
    printExternalAddress(env, logicalName, theValue, getSymbolicName<T>());
}

using PrintFunction = void (*)(RawEnvironment*, const char*, void*);
using DiscardFunction = bool (*)(RawEnvironment*, void*);
using NewFunction = void(*)(UDFContext*, UDFValue*);
using CallFunction = bool(*)(UDFContext*, UDFValue*, UDFValue*);

using ExpansionFunction = std::function<void(RawEnvironment*)>;
using WrappedExpansionFunction = EnvironmentFunction<void>;

template<typename T>
T extractData(Environment& env, Value* obj);
class IORouter;
/// Wrapper class to handle the use of a clips environment
class Environment
{
public:
    class AllocationError : public Neutron::Exception
    {
        public:
            /// Always a useful typedef when using inheritance
            using inherited = Neutron::Exception;

            using inherited::inherited;
            virtual ~AllocationError() = default;
    };
    class DeallocationError : public Neutron::Exception
    {
        public:
            /// Always a useful typedef when using inheritance
            using inherited = Neutron::Exception;

            using inherited::inherited;
            virtual ~DeallocationError() = default;
    };
public:
    /// Construct a new electron environment and initialize it
    Environment();

    /// Reclaims the memory of a given electron environment if allowed
    virtual ~Environment();

    /// Calls the reset function within CLIPS
    void reset() noexcept;

    /// Runs the given CLIPS environment (rule execution)
    /// @return The number of rules fired
    int64 run(int64 count = -1L) noexcept;

    /// Loads the given source file into the given clips environment
    void loadFile(const Neutron::Path& path);

    /// Return the raw environment pointer, USE ONLY IN CASES WHERE FUNCTIONALITY IS MISSING IN THIS CLASS
    RawEnvironment* getRawEnvironment() const noexcept { return _env; }

    /// Passes in the raw environment to a given function, usually used to define functions
    void applyToFunction(ExpansionFunction fn);

    /// Enable watch items in the environment
    void watch(const std::string& targets);

    /// disable watch items in the environment
    void unwatch(const std::string& targets);

    Fact* assertString(const std::string& value) noexcept;
    /**
     * Try to assert the given string as a fact, if it fails then
     * throw an exception.
     * @param fact the fact text to assert
     * @return the fact pointer that was successfully asserted or already exists
     * @throws Neutron::Exception unable to assert the given fact
     */
    Fact* assertStringOrThrow(const std::string& fact);

    auto createSymbol(const std::string& symbol) noexcept           { return ::CreateSymbol(_env, symbol.c_str()); }
    auto createSymbol(const Neutron::Path& symbol) noexcept         { return ::CreateSymbol(_env, symbol.string().c_str()); }
    auto createSymbol(const char* string) noexcept                  { return ::CreateSymbol(_env, string); }
    auto createString(const char* string) noexcept                  { return ::CreateString(_env, string); }
    auto createString(const std::string& symbol) noexcept           { return ::CreateString(_env, symbol.c_str()); }
    auto createString(const Neutron::Path& symbol) noexcept         { return createString(symbol.string()); }
    auto createInstanceName(const std::string& symbol) noexcept     { return ::CreateInstanceName(_env, symbol.c_str()); }
    auto createInstanceName(const Neutron::Path& symbol) noexcept   { return ::CreateInstanceName(_env, symbol.string().c_str()); }
    auto createBool(bool value) noexcept                            { return ::CreateBoolean(_env, value); }
    auto falseSymbol() noexcept                                     { return FalseSymbol(_env); }
    auto trueSymbol() noexcept                                      { return TrueSymbol(_env); }
    auto createInteger(int64 value) noexcept                        { return ::CreateInteger(_env, value); }
    auto createFloat(double value) noexcept                         { return ::CreateFloat(_env, value); }
    auto emptyMultifield() noexcept                                 { return ::EmptyMultifield(_env); }

    template<typename T>
    auto createExternalAddress(T* value) noexcept
    {
        return ::CreateExternalAddress(_env, static_cast<void*>(value), ExternalAddressCache<T>::getExternalAddressId(*this));
    }


    template<typename T>
    auto createExternalAddress(T& value) noexcept
    {
        return createExternalAddress(&value);
    }

    /**
     * invoke a function with no arguments and discarding its result.
     * @param function the function to invoke
     */
    void call(const std::string& function);

    /**
     * invoke a function with no arguments while saving its result.
     * @param function the function to invoke
     * @param ret the data object to stash the result in
     */
    void call(const std::string& function, Value* ret);

    /// Build a function expression and then execute it
    /// @param function the name of the function to execute
    /// @param ret The DataObject pointer to store the result in
    /// @param args The variadic list of arguments useful for execution
    template<typename ... Args>
    void call(const std::string& function, Value* ret, Args&& ... args)
    {
        FunctionBuilder fb(*this);
        fb.addArguments(std::forward<Args>(args)...);
        fb.call(function, ret);
    }

    /// Build a function expression, execute it, and convert the results
    /// @param function the name of the function to execute
    /// @param ret The data object to store the result in
    /// @param args The variadic list of arguments useful for execution
    template<typename R, typename ... Args>
    R call(const std::string& function, Args&& ... args)
    {
        Value r;
        call(function, &r, std::forward<Args>(args)...);
        return extractValue<R>(&r);
    }

    /**
     * Build a function expression, execute it, and convert the results using a
     * provided function.
     * @tparam Args the variadic template parameter representing the set of arguments (this will be transparent)
     * @param function the name of the function to invoke
     * @param ret the function to execute when execution is finished which will perform conversion.
     * @param args the set of arguments to invoke the function with
     */
    template<typename ... Args>
    void call(const std::string& function, EnvironmentFunction<void, Value*> ret, Args&& ... args)
    {
        Value r;
        call(function, &r, std::forward<Args>(args)...);
        ret(*this, &r);
    }

    /// Extract data out of the given data object using the provided function
    /// @param dobj the data object to extract data from
    /// @param fn the function which will convert the given data object to data
    void extractValue(Value* dobj, EnvironmentFunction<void, Value*> fn);

    /// Extract data out of the given data object using the provided function
    /// @param dobj the data object to extract data from
    /// @param fn the function which will convert the given data object to data
    void extractValue(UDFValue* dobj, EnvironmentFunction<void, UDFValue*> fn);

    /**
     * Extracts data out of the given DataObject and places it in the provided
     * value according to an implementation of extractData
     * @tparam T the type of the value to store to
     * @param data the data object to extract data out of
     * @param value the thing to store the extracted data into
     */
    template<typename T>
    T extractValue(Value* data)
    {
        return extractData<T>(*this, data);
    }

    template<typename T>
    T extractValue(UDFValue* data)
    {
        return extractData<T>(*this, data);
    }

    /**
     * Register an external address type with the registration system, it is
     * bound to this environment, this is normally used internally but is
     * exposed in case something is missing.
     * @tparam T the type of the external address
     * @param description A pointer to an external address type structure
     * @return boolean value signifying if the registration was successful (the type wasn't already registered before)
     */
    template<typename T>
    bool registerExternalAddressType(ExternalAddressRegistration* description)
    {
        // do a check to make sure that we didn't register the same type multiple times for a given environment
        // Once a type is registered, it cannot be done again. If you need to register multiple times then please
        // rethink how you're doing things
        if (!ExternalAddressCache<T>::typeRegistered(*this)) {
            ExternalAddressCache<T>::registerExternalAddressId(*this, ::InstallExternalAddressType(_env, description));
            // also register a lambda to make deregistration possible
            _externalAddressDeregistrationList.emplace_back([this]() { ExternalAddressCache<T>::deregister(*this); });
            return true;
        }
        return false;
    }

    /**
     * Register an external address type with the registration system, it is
     * bound to this environment.
     * @tparam T the type of the external address
     * @param title the symbolic id of the external address type, this will be used in CLIPS code to reference this type during construction
     * @param _new A pointer to the function which will construct a new instance of the given external address, can be nullptr.
     * @param _call A pointer to the function which is invoked when call is used inside CLIPS, can be a nullptr.
     * @param _delete A pointer to the function which is invoked when the given external address needs to be deleted, can be nullptr.
     * @param _print A pointer to the function which provides a printable representation of the given external address.
     * @overload
     * @return boolean value signifying if the registration was successful (the type wasn't already registered before)
     */
    template<typename T>
    bool registerExternalAddressType(const char* title, NewFunction _new, CallFunction _call, DiscardFunction _delete, PrintFunction _print = Electron::printExternalAddress<T>)
    {
        ExternalAddressRegistration container = {
            title,
            _print,
            _print,
            _delete,
            _new,
            _call,
        };
        return registerExternalAddressType<T>(&container);
    }

    /**
     * Register an external address type with the registration system, it is
     * bound to this environment.
     * @tparam T the type of the external address
     * @param title the symbolic id of the external address type, this will be used in CLIPS code to reference this type during construction
     * @param _new A pointer to the function which will construct a new instance of the given external address, can be nullptr.
     * @param _call A pointer to the function which is invoked when call is used inside CLIPS, can be a nullptr.
     * @param _delete A pointer to the function which is invoked when the given external address needs to be deleted, can be nullptr.
     * @param _print A pointer to the function which provides a printable representation of the given external address.
     * @overload
     * @return boolean value signifying if the registration was successful (the type wasn't already registered before)
     */
    template<typename T>
    bool registerExternalAddressType(const std::string& title, NewFunction _new, CallFunction _call, DiscardFunction _delete, PrintFunction _print = Electron::printExternalAddress<T>)
    {
        return registerExternalAddressType<T>(title.c_str(), _new, _call, _delete, _print);
    }

    /**
     * Register an external address type with the registration system, it is
     * bound to this environment; the name of the external address is acquired
     * via the getSymbolicName<T>() function and must be implemented for the
     * given type.
     * @tparam T the type of the external address
     * @param _new A pointer to the function which will construct a new instance of the given external address, can be nullptr.
     * @param _call A pointer to the function which is invoked when call is used inside CLIPS, can be a nullptr.
     * @param _delete A pointer to the function which is invoked when the given external address needs to be deleted, can be nullptr.
     * @param _print A pointer to the function which provides a printable representation of the given external address.
     * @overload
     * @return boolean value signifying if the registration was successful (the type wasn't already registered before)
     */
    template<typename T>
    bool registerExternalAddressType(NewFunction _new, CallFunction _call, DiscardFunction _delete, PrintFunction _print = Electron::printExternalAddress<T>)
    {
        return registerExternalAddressType<T>(getSymbolicName<T>(), _new, _call, _delete, _print);
    }

    /**
     * Get the index of the given external address id for this environment.
     * @tparam T The type of the external address
     * @return An integer representation of the given external address id
     */
    template<typename T>
    auto getExternalAddressId()
    {
        return ExternalAddressCache<T>::getExternalAddressId(*this);
    }





    /**
     * Install a custom native function into the environment which can be
     * called from CLIPS code like any other function.
     * @param name The name of the function
     * @param returnTypes A string representation of the types of the values expected to be returned, each character in the string is a different accepted type;
     * the types are checked on value returned by CLIPS.
     * @param minArgs the minimum number of arguments to be passed to the function
     * @param maxArgs the maximum number of arguments to be passed to the function
     * @param argTypes A string that denotes the expected/allowed types for each argument
     * @param cfp body to execute
     * @param cname Name of the c function itself (used for c code generation)
     * @param context A pointer to something (can be omitted)
     * @return a boolean signifying if the installation was successful or not
     */
    bool addFunction(const std::string& name,  const std::string& returnTypes, uint16 minArgs, uint16 maxargs, const std::string& argTypes, ::UserDefinedFunction cfp, const std::string& cName, void* context = nullptr);
    bool addFunctionNoArgs(const std::string& name, const std::string& returnTypes, ::UserDefinedFunction cfp, const std::string& cName, void* context = nullptr);

    template<typename T>
    bool externalAddressIsOfType(Value* ptr)
    {
        return ptr->externalAddressValue->type == getExternalAddressId<T>();
    }
    template<typename T>
    bool externalAddressIsOfType(Value& ptr)
    {
        return externalAddressIsOfType<T>(&ptr);
    }

    template<typename T>
    bool externalAddressIsOfType(UDFValue* ptr)
    {
        return ptr->externalAddressValue->type == getExternalAddressId<T>();
    }

    template<typename T>
    bool externalAddressIsOfType(UDFValue& ptr)
    {
        return externalAddressIsOfType<T>(&ptr);
    }

    /**
     * convert the given data object pointer containing an external address to the
     * given template type.
     * @return the casted value
     * @param ptr The pointer to the data object containing the external address
     */
    template<typename T>
    T* fromExternalAddress(Value* ptr)
    {
        return static_cast<T*>(ptr->externalAddressValue->contents);
    }
    template<typename T>
    T* fromExternalAddress(Value& ptr)
    {
        return fromExternalAddress<T>(&ptr);
    }

    template<typename T>
    T& fromExternalAddressAsRef(Value* ptr)
    {
        return *(fromExternalAddress<T>(ptr));
    }

    template<typename T>
    T& fromExternalAddressAsRef(Value& ptr)
    {
        return fromExternalAddressAsRef<T>(&ptr);
    }

    /**
     * convert the given data object pointer containing an external address to the
     * given template type.
     * @return the casted value
     * @param ptr The pointer to the data object containing the external address
     */
    template<typename T>
    T* fromExternalAddress(UDFValue* ptr)
    {
        return static_cast<T*>(ptr->externalAddressValue->contents);
    }

    template<typename T>
    T* fromExternalAddress(UDFValue& ptr)
    {
        return fromExternalAddress<T>(&ptr);
    }

    template<typename T>
    T& fromExternalAddressAsRef(UDFValue* ptr)
    {
        return *(fromExternalAddress<T>(ptr));
    }

    template<typename T>
    T& fromExternalAddressAsRef(UDFValue& ptr)
    {
        return fromExternalAddressAsRef<T>(&ptr);
    }

    using RawIORouterQueryFunction  =   bool (*)(RawEnvironment*, const char*, void*);
    using RawIORouterWriteFunction  =   void (*)(RawEnvironment*, const char*, const char*, void*);
    using RawIORouterExitFunction   =   void (*)(RawEnvironment*, int, void*);
    using RawIORouterReadFunction   =   int  (*)(RawEnvironment*, const char*, void*);
    using RawIORouterUnreadFunction =   int  (*)(RawEnvironment*, const char*, int, void*);

    /**
     * A basic IO router to the underlying environment.
     * @param name the name to refer to the router by inside clips
     * @param priority the priority of the given router (the order the routers are queried in!)
     * @param onQuery the function to invoke when router querying must be performed
     * @param onWrite the write function associated with this router
     * @param onExit the function to invoke when the router is requested to exit
     * @param onRead the function that is called when the router is requested to read
     * @param onUnread the function that is called when the router is requested to unread
     * @param context data specific to this io router that will be passed to the above functions on invocation
     * @return boolean value signifying if the router was successfully added
     */
    bool addRouter(const char* name, int priority, RawIORouterQueryFunction onQuery, RawIORouterWriteFunction onWrite, RawIORouterExitFunction onExit, RawIORouterReadFunction onRead, RawIORouterUnreadFunction onUnread, void* context = nullptr) noexcept;
    /**
     * A basic IO router to the underlying environment.
     * @param name the name to refer to the router by inside clips
     * @param priority the priority of the given router (the order the routers * are queried in!)
     * @param onQuery the function to invoke when router querying must be performed
     * @param onWrite the write function associated with this router
     * @param onExit the function to invoke when the router is requested to exit
     * @param onRead the function that is called when the router is requested to read
     * @param onUnread the function that is called when the router is requested to unread
     * @param context data specific to this io router that will be passed to the above functions on invocation
     * @return boolean value signifying if the router was successfully added
     */
    bool addRouter(const std::string& name, int priority, RawIORouterQueryFunction onQuery, RawIORouterWriteFunction onWrite, RawIORouterExitFunction onExit, RawIORouterReadFunction onRead, RawIORouterUnreadFunction onUnread, void* context = nullptr) noexcept;

    /**
     * Install an IO router object into the given environment!
     * @param router the router to install, this object must not go out of scope or be destroyed while the environment is holding onto it!
     * @return a boolean value singifying if the router was successfully added
     */
    bool addRouter(IORouter* router) noexcept;


    /**
     * Install a series of lambdas for the different operations as an IO router
     * @param name the logical name of the router
     * @param priority the priority of the router
     * @param onQuery the function to invoke when router querying must be performed
     * @param onWrite the write function associated with this router
     * @param onExit the function to invoke when the router is requested to exit
     * @param onRead the function that is called when the router is requested to read
     * @param onUnread the function that is called when the router is requested to unread
     * @return a heap allocated IORouter, if it is nullptr then the
     * addition was a failure, you must hold onto this for the life of the
     * program or until the router is deallocated!
     */
    std::unique_ptr<IORouter> addRouter(const char* name, int priority, RouterQueryFunction onQuery, RouterWriteFunction onWrite, RouterExitFunction onExit, RouterReadFunction onRead, RouterUnreadFunction onUnread) noexcept;

    /**
     * Active the given router if it was previously deactivated.
     * @param name the name of the router to reactivate
     * @return boolean value signifying that the logical name was recognized
     */
    bool activateRouter(const std::string& name) noexcept;

    /**
     * Deactivate the given router to prevent it from being queried (useful
     * when you want to construct routers which wrap other routers) until
     * reactivated.
     * @param name the name of the router to deactivate
     * @return boolean value signifying if the given router was recoginzed
     */
    bool deactivateRouter(const std::string& name) noexcept;

    /**
     * Temporaryily deactivate a given router, once this object goes out of
     * scope then reactivate the given router!
     */
    class RouterDeactivator {
        public:
            RouterDeactivator(Environment& parent, const std::string& name);
            virtual ~RouterDeactivator();
        private:
            Environment& _parent;
            std::string _name;
    };

    void write(const char* logicalName, const char* str) noexcept;
    void write(const char* logicalName, const std::string& str) noexcept;

    auto readRouter(const char* logicalName) noexcept;
    auto readRouter(const std::string& logicalName) noexcept;
    auto unreadRouter(const char* logicalName, int ch) noexcept;
    auto unreadRouter(const std::string& logicalName, int ch) noexcept;

    /**
     * Add the given path to the front of the include path
     * @param path the path to add
     * @throw Neutron::Exception this environment is not registered with the IncludePathCache
     */
    void addToIncludePathFront(const Neutron::Path& path);

    /**
     * Add the given path to the back of the include path
     * @param path the path to add
     * @throw Neutron::Exception this environment is not registered with the IncludePathCache
     */
    void addToIncludePathBack(const Neutron::Path& path);


    using IncludePathList = std::list<Neutron::Path>;
    const IncludePathList& getIncludePathList() const noexcept { return _path; }
    bool evaluationErrorOccurred() const noexcept { return ::GetEvaluationError(_env); }
    void setEvaluationErrorOccurred(bool error = true) noexcept { ::SetEvaluationError(_env, error); }
    void resetEvaluationErrorOccurred() noexcept { setEvaluationErrorOccurred(false); }

    /**
     * Snapshot the current environment as a binary image to disk.
     * @param saveLocation Where to save the target to disk
     */
    void compileToBinaryFile(const Neutron::Path& saveLocation) noexcept;
    /**
     * Load a binary image from disk into this environment
     * @param location Where the binary image is located
     */
    void loadBinaryImage(const Neutron::Path& location) noexcept;

    /**
     * Try to get the first argument during the invocation of a UDF
     */
    bool firstArgument(UDFContext* context, uint32 expectedType, UDFValue* out) { return ::UDFFirstArgument(context, expectedType, out); }
    /**
     * Try to get the next argument during the invocation of a UDF
     */
    bool nextArgument(UDFContext* context, uint32 expectedType, UDFValue* out) { return ::UDFNextArgument(context, expectedType, out); }
    /**
     * Try to get a specific UDFValue based off of index during UDF execution
     */
    bool nthArgument(UDFContext* context, uint32 index, uint32 expectedType, UDFValue* out) { return ::UDFNthArgument(context, index, expectedType, out); }
    /**
     * Check and see if the given UDF has more arguments
     */
    bool hasNextArgument(UDFContext* context) noexcept;
    /**
     * Embed an error value, useful during UDF execution when the return cannot be an error message!
     */
    void setErrorValue(::TypeHeader* theValue) noexcept;
    /**
     * Get the number of arguments for this UDF
     */
    uint32 getArgumentCount(UDFContext* context) noexcept;

    /// Batches the file (load as a script) into the given clips environment
    bool batchFile(const Neutron::Path& path, bool silent = true);

    using RawVoidCallFunction = void(*)(RawEnvironment*, void*);
    /**
     * Add a uniquely named callback function to be invoked on the clear function being called
     * @param name the unique name of this callback function
     * @param f the function to invoke when clear is called that is bound to the unique name
     * @param p the priority which denotes the order to execute in, the range is (-2000,2000)
     * @param context Any special data that must be passed to the callback during invocation
     * @return boolean value signifying if the callback was successfully added
     */
    bool addClearFunction(const char* name, RawVoidCallFunction f, int priority, void* context = nullptr) noexcept;

    /**
     * Add a uniquely named callback function to be invoked on the clear function being called
     * @param name the unique name of this callback function
     * @param f the function to invoke when clear is called that is bound to the unique name
     * @param p the priority which denotes the order to execute in, the range is (-2000,2000)
     * @param context Any special data that must be passed to the callback during invocation
     * @return boolean value signifying if the callback was successfully added
     */
    bool addClearFunction(const std::string& name, RawVoidCallFunction f, int priority, void* context = nullptr) noexcept;

    /**
     * Remove the uniquely identified clear callback function
     * @param name the name of the callback function to remove
     * @return true on successful removal
     */
    bool removeClearFunction(const char* name) noexcept;

    /**
     * Remove the uniquely identified clear callback function
     * @param name the name of the callback function to remove
     * @return true on successful removal
     */
    bool removeClearFunction(const std::string& name) noexcept;

    using RawRuleFiredFunction = ::RuleFiredFunction;
    using RuleFiredFunction = void(*)(Environment&, Activation*, void*);

    /// @todo add the AfterRuleFires and BeforeRuleFires functions

    /**
     * Retrieve a token using either an internal CLIPS handle or a real name; use this
     * version if you are passing internal clips read sources around!
     * @param name the name/handle to read from
     * @param tok the location to store token data to on success
     * @overload
     */
    void getToken(const char* name, Token* tok);
    void getToken(const char* name, Token& tok);
    inline void getToken(const std::string& name, Token* tok) noexcept { getToken(name.c_str(), tok); }
    inline void getToken(const std::string& name, Token& tok) noexcept { getToken(name.c_str(), tok); }
    inline Token getToken(const std::string& name) noexcept {
        Token tok;
        getToken(name, tok);
        return tok;
    }
    void syntaxErrorMessage(const std::string& name);
    /**
     * A generalized method for reporting errors during file open operations
     */
    void openErrorMessage(const std::string& name, const std::string& message);
    void cantFindItemErrorMessage(const std::string& name, const std::string& message, bool useQuotes = true);
    Instance* instanceNameToAddress(Lexeme*) noexcept;
    UnmakeInstanceError unmakeInstance(Instance* i) noexcept;

public:
    void addPathToIncludedFileSet(const Neutron::Path& p);
    bool fileAlreadyIncluded(const Neutron::Path& p);
    void clearIncludedFileSet() noexcept;
public:
    /**
     * Parses the input string and tries to build a construct off of it; 
     * This is not the same thing as eval, it is used for all the def* calls
     * @param construct The string to parse and hopefully build a construct off of
     * @throw Neutron::Exception Could not build the given construct statement
     * @throw Neutron::Exception Construct that is trying to be built was not found
     * @throw Neutron::Exception Parsing error during the process of building
     */
    void build(const std::string& construct);
private:
    template<typename T>
    static void isaFunction(UDF_ARGS__)
    {
        auto &theEnv = fromRaw(env);
        UDFValue dobj;
        if (!theEnv.firstArgument(context, ArgumentBits::ExternalAddress, &dobj)) {
            out->lexemeValue = theEnv.falseSymbol();
        } else {
            out->lexemeValue = theEnv.createBool(theEnv.externalAddressIsOfType<std::decay_t<T>>(&dobj));
        }
    }
    template<typename T>
    static void emptyFunction(UDF_ARGS__)
    {
        auto &theEnv = fromRaw(env);
        UDFValue dobj;
        if (!theEnv.firstArgument(context, ArgumentBits::ExternalAddress, &dobj)) {
            out->lexemeValue = theEnv.falseSymbol();
        } else {
            using K = std::decay_t<T>;
            if constexpr (Neutron::is_wrapped_ptr_v<K>) {
                auto& ptr = theEnv.fromExternalAddressAsRef<K>(dobj);
                out->lexemeValue = theEnv.createBool(ptr->empty());
            } else {
                out->lexemeValue = theEnv.createBool(theEnv.fromExternalAddress<K>(dobj)->empty());
            }

        }
    }

    template<typename T>
    static void sizeFunction(UDF_ARGS__)
    {
        auto &theEnv = fromRaw(env);
        UDFValue dobj;
        if (!theEnv.firstArgument(context, ArgumentBits::ExternalAddress, &dobj)) {
            out->lexemeValue = theEnv.falseSymbol();
        } else {
            using K = std::decay_t<T>;
            if constexpr (Neutron::is_wrapped_ptr<K>::value) {
                auto& ptr = theEnv.fromExternalAddressAsRef<K>(dobj);
                out->integerValue = theEnv.createInteger(ptr->size());
            } else {
                out->integerValue = theEnv.createInteger(theEnv.fromExternalAddress<K>(dobj)->size());
            }
        }
    }

    template<typename T>
    static void getNameFunction(UDF_ARGS__)
    {
        auto& theEnv = fromRaw(env);
        UDFValue dobj;
        if (!theEnv.firstArgument(context, ArgumentBits::ExternalAddress, &dobj)) {
            out->lexemeValue = theEnv.falseSymbol();
        } else {
            using K = std::decay_t<T>;
            if constexpr (Neutron::is_wrapped_ptr<K>::value) {
                auto& ptr = theEnv.fromExternalAddressAsRef<K>(dobj);
                out->lexemeValue = theEnv.createSymbol(ptr->getName());
            } else {
                // assume it is a symbol for the time being
                out->lexemeValue = theEnv.createSymbol(theEnv.fromExternalAddress<std::decay_t<T>>(dobj)->getName());
            }
        }
    }

public:
    /**
     * Register a UDF with clips that checks to see if the external address is of a given type
     * @tparam T The type of the external address to check
     * @param name the name of the function as will be invoked inside of clips
     */
     template<typename T>
     void addExternalAddressTypeCheckFunction(const std::string& name)
     {
         std::ostringstream ss;
         ss << "Electron::isaFunction<" << getSymbolicName<T>() << ">";
         auto str = ss.str();
         addFunction(name, "b", 1, 1, "e;e", isaFunction<T>, str);
     }

    /**
     * Register a UDF with clips that returns the number of elements contained in the given type
     * @tparam T The type of the external address to check
     * @param name the name of the function as will be invoked inside of clips
     */
    template<typename T>
    void addEmptyExternalAddressFunction(const std::string& name)
    {
        std::ostringstream ss;
        ss << "Electron::emptyFunction<" << getSymbolicName<T>() << ">";
        auto str = ss.str();
        addFunction(name, "b", 1, 1, "e;e", emptyFunction<T>, str);
    }

    /**
     * Register a UDF with this clips environment which gets the size of the container inside the external address
     * @tparam T The type of the external address to check
     * @param name the name of the function as will be invoked inside of clips
     */
     template<typename T>
     void addSizeExternalAddressFunction(const std::string& name)
     {
         std::ostringstream ss;
         ss << "Electron::sizeFunction<" << getSymbolicName<T>() << ">";
         auto str = ss.str();
         addFunction(name, "l", 1, 1, "e;e", sizeFunction<T>, str);
     }

    /**
     * Register a UDF which retrieves the name of a given external address
     * @tparam T The type of the external address to check
     * @param name the name of the function as will be invoked inside of clips
     */
     template<typename T>
     void addGetNameExternalAddressFunction(const std::string& name)
     {
         std::ostringstream ss;
         ss << "Electron::getNameFunction<" << getSymbolicName<T>() << ">";
         auto str = ss.str();
         addFunction(name, "y", 1, 1, "e;e", getNameFunction<T>, str);
     }
public:
     /**
      * Given a provided class, call its corresponding InstallExtensions static method. A compile time error
      * will happen if the method in question does not have the apropriate method implemented!
      * @tparam T The class that has an InstallExtensions method to be invoked
      */
     template<typename T>
     void installExtensionsFromType() noexcept {
         using K = std::decay_t<T>;
         K::InstallExtensions(this);
     }
public:
     /**
      * attempt to find the given defrule from its name
      */
     Defrule* findDefrule(const std::string& name) const noexcept;
     Deftemplate* findDeftemplate(const std::string& name) const noexcept;
public:
     operator RawEnvironment*() const { return this->getRawEnvironment(); }

private:
    void installIncludePathFunctions();

public:
    template<typename T>
    Neutron::non_owning_ptr<Instance> getInstance(T* value)
    {
        using K = std::decay_t<T>;
        if constexpr (std::is_same_v<K, UDFValue>) {
            return getInstance(reinterpret_cast<Value*>(value->value));
        } else if constexpr (std::is_same_v<K, Value>) {
            using R = Neutron::non_owning_ptr<Instance>;
            if (isInstanceName(value)) {
                return R(instanceNameToAddress(value->lexemeValue));
            } else if (isInstanceAddress(value)) {
                return R(value->instanceValue);
            } else {
                return nullptr;
            }
        } else {
            static_assert(Neutron::DependentFalse<T>::value, "Illegal type provided!");
        }
    }
    template<typename T>
    auto getInstance(T& value) {
        return getInstance(&value);
    }
    void destroy();
public:
    void setHaltExecution(bool value) noexcept {
        ::SetHaltExecution(_env, value);
    }
    void setEvaluationError(bool value) noexcept {
        ::SetEvaluationError(_env, value);
    }
    void illegalLogicalNameMessage(const std::string& function) noexcept {
        ::IllegalLogicalNameMessage(_env, function.c_str());
    }
    void unrecognizedRouterMessage(const std::string& function) noexcept {
        ::UnrecognizedRouterMessage(_env, function.c_str());
    }
    bool queryRouters(const std::string& logicalName) noexcept {
        return ::QueryRouters(_env, logicalName.c_str());
    }
    RouterDataModule& routerData() { return *RouterData(_env); }
    const RouterDataModule& routerData() const noexcept { return *RouterData(_env); }
    ExpressionDataModule& expressionData() { return *ExpressionData(_env); }
    const ExpressionDataModule& expressionData() const noexcept { return *ExpressionData(_env); }
    ConstructDataModule& constructData() { return *ConstructData(_env); }
    const ConstructDataModule& constructData() const noexcept { return *ConstructData(_env); }
public:
    [[nodiscard]] inline RawActivation* getFirstActivation() noexcept { return ::GetNextActivation(_env, nullptr); }
    [[nodiscard]] inline bool agendaChanged() const noexcept { return ::GetAgendaChanged(_env); }
    inline void setAgendaChanged(bool value = true) noexcept { ::SetAgendaChanged(_env, value); }
    [[nodiscard]] inline auto numberOfActivations() const noexcept { return ::GetNumberOfActivations(_env); }
private:
    using IncludedFilesSet = std::set<Neutron::Path>;
    RawEnvironment* _env;
    IncludePathList _path;
    void* _importConstruct;
    void* _useModuleDeclConstruct;
    void* _useModuleTypeConstruct;
    void* _useModuleLogicConstruct;
    IncludedFilesSet _includedFiles;
    std::list<std::function<void()>> _externalAddressDeregistrationList;

private:
    class Registration {
        public:
            Registration() = default;
            ~Registration() = default;
            Registration(const Registration&) = delete;
            Registration(Registration&&) = delete;
            Registration& operator=(const Registration&) = delete;
            Registration&& operator=(Registration&&) = delete;
            void add(Environment& env);
            void remove(Environment& env);
            Environment &fromEnv(RawEnvironment* env);
        private:
            std::unordered_map<RawEnvironment*, Environment*> _map;
    };
    static Registration *_envTracker;
    static inline void createRegistration()
    {
      if (!_envTracker) {
        _envTracker = new Registration();
      }
    }
    inline void registerEnv() { createRegistration(); _envTracker->add(*this); }
    void deregisterEnv();

public:
    /**
     * Retrieve the corresponding Environment wrapper given the raw CLIPS environment
     * @param rawEnv the raw environment pointer that CLIPS uses directly
     * @return The corresponding environment wrapper
     * @throw Neutron::Exception the given raw environment pointer isn't registered with an environment wrapper
     */
    static inline Environment &fromRaw(RawEnvironment* rawEnv) { return _envTracker->fromEnv(rawEnv); }

};


template<>
bool Environment::extractValue<bool>(Value* data);

/**
 * Extract the integer or enum value stored within the provided DataObject and cast to the provided type,
 * if the given type isn't an enum or integer type then a static_assert will fire.
 * @tparam T the type of the storage container
 * @param env the environment to get information from
 * @param obj the data object to extract the integer or enum value from
 */
template<typename T>
T extractData(Environment& env, Value* obj)
{
    if constexpr (std::numeric_limits<T>::is_integer) {
        return static_cast<T>(obj->integerValue->contents);
    } else if constexpr (std::is_enum<T>::value) {
        return static_cast<T>(obj->integerValue->contents);
    } else if constexpr (std::is_floating_point<T>::value) {
        return static_cast<T>(obj->floatValue->contents);
    } else {
        static_assert(std::numeric_limits<T>::is_integer ||
                std::is_enum<T>::value ||
                std::is_floating_point<T>::value, "Custom impl required!");
        return T();
    }
}

template<typename T>
T extractData(Environment& env, Value& obj) 
{
    return extractData<T>(env, &obj);
}

template<typename T>
T extractData(Environment& env, UDFValue* obj)
{
    // A UDF value has extra tags surrounding a Value object so we can take the address of
    // the value field and cast that to a basic Value for our purposes then call extractData
    return extractData<T>(env, reinterpret_cast<Value*>(&(obj->value)));
}
template<typename T>
T extractData(Environment& env, UDFValue& obj) 
{
    return extractData<T>(env, &obj);
}

template<typename T>
FunctionBuilder::FunctionBuilderModifier
FunctionBuilder::externalAddress(T* thingToWrapAsExternalAddress)
{
    return [thingToWrapAsExternalAddress](FunctionBuilder* fb) {
        fb->add(fb->_env.createExternalAddress(thingToWrapAsExternalAddress));
    };
}


template<typename T>
void
FunctionBuilder::add(T* externalAddress) {
    add(_env.createExternalAddress(externalAddress));
}

template<typename T>
std::unordered_map<RawEnvironment*, int> ExternalAddressCache<T>::_cache;


template<typename T>
int
ExternalAddressCache<T>::getExternalAddressId(RawEnvironment* env)
{
    if (auto found = _cache.find(env); found != _cache.end()) {
        return found->second;
    } else {
        throw Neutron::Exception(__HERE__, "Attempted to get the external address index of something not registered from using an unregistered environment!");
    }
}


template<typename T>
int
ExternalAddressCache<T>::getExternalAddressId(Environment& env)
{
    return getExternalAddressId(env.getRawEnvironment());
}

template<typename T>
void
ExternalAddressCache<T>::registerExternalAddressId(RawEnvironment* env, int result)
{
    _cache.emplace(env, result);
}

template<typename T>
void
ExternalAddressCache<T>::registerExternalAddressId(Environment& env, int result)
{
    registerExternalAddressId(env.getRawEnvironment(), result);
}

template<typename T>
void
ExternalAddressCache<T>::deregister(Environment& env)
{
    deregister(env.getRawEnvironment());
}

template<typename T>
void
ExternalAddressCache<T>::deregister(RawEnvironment* env)
{
    _cache.erase(env);
}
template<typename T>
bool
ExternalAddressCache<T>::typeRegistered(Environment& env)
{
    return typeRegistered(env.getRawEnvironment());
}

template<typename T>
bool
ExternalAddressCache<T>::typeRegistered(RawEnvironment* env)
{
    return _cache.find(env) != _cache.end();
}

template<typename T>
void
populateStringContainer(Environment& env, Value* obj, T& container)
{
    if (obj->header->type != Types::Multifield) {
        throw Neutron::Exception(__HERE__, "Not a multifield!");
    }
    for (size_t index = 0; index < obj->multifieldValue->length; ++index) {
        if (auto &curr = obj->multifieldValue->contents[index]; !usesLexemeField(curr)) {
            throw Neutron::Exception(__HERE__, "Illegal type for the container");
        } else {
            std::string tmp(curr.lexemeValue->contents);
            container.emplace_back(std::move(tmp));
        }
    }
}
template<typename T>
void
populateStringContainer(Environment& env, Value* obj, std::set<T>& container)
{
    if (obj->header->type != Types::Multifield) {
        throw Neutron::Exception(__HERE__, "Not a multifield!");
    }
    for (size_t index = 0; index < obj->multifieldValue->length; ++index) {
        if (auto& curr = obj->multifieldValue->contents[index]; !usesLexemeField(curr)) {
            throw Neutron::Exception(__HERE__, "Illegal type for the container");
        } else {
            std::string tmp(curr.lexemeValue->contents);
            container.emplace(std::move(tmp));
        }
    }
}

template<typename T>
void
populateExternalAddressContainer(Environment& env, Value* mf, std::list<T*>& container)
{
    if (!isMultifield(mf)) {
        throw Neutron::Exception(__HERE__, "Not a multifield!");
    }
    for (size_t index = 0; index < mf->multifieldValue->length; ++index) {
        if (auto& curr = mf->multifieldValue->contents[index]; !isExternalAddress(curr)) {
            throw Neutron::Exception(__HERE__, "Expected a external address!");
        } else if (env.externalAddressIsOfType<T>(curr)) {
            container.emplace_back(env.fromExternalAddress<T>(curr));
        } else {
            throw Neutron::Exception(__HERE__, "external address is not of the appropriate type!");
        }
    }
}

template<typename T>
void
populateExternalAddressContainer(Environment& env, Value* mf, std::list<T>& container)
{
    if (!isMultifield(mf)) {
        throw Neutron::Exception(__HERE__, "Not a multifield!");
    }
    for (size_t index = 0; index < mf->multifieldValue->length; ++index) {
        if (auto& curr = mf->multifieldValue->contents[index]; !isExternalAddress(curr)) {
            throw Neutron::Exception(__HERE__, "Expected a external address!");
        } else if (env.externalAddressIsOfType<T>(curr)) {
            container.emplace_back(env.fromExternalAddressAsRef<T>(curr));
        } else {
            throw Neutron::Exception(__HERE__, "external address is not of the appropriate type!");
        }
    }
}

template<typename T>
T
populateStringContainer(Environment& env, Value* obj)
{
    T container;
    populateStringContainer(env, obj, container);
    return container;
}



EnvironmentFunction<void, Value*> populateStreamWithStrings(std::ostream& output);
/// Extract a multifield of strings out of a given DataObject and place its contents inside a std::list
/// @param dobj The data object to extract the multifield contents from
/// @param list A reference to a std::list<string> to store the multifield contents in
template<>
std::list<std::string>
extractData<std::list<std::string>>(Environment& env, Value* obj);

/// Extract a multifield of strings out of a given DataObject and place its contents inside a std::vector as paths
/// @param dobj The data object to extract the multifield contents from
/// @param list A reference to a std::vector<alex::path> to store the multifield contents in
/// @todo  implement a funcall wrapper for this extractData call.
template<>
std::vector<Neutron::Path>
extractData<std::vector<Neutron::Path>>(Environment& env, Value* dobj);


/// Extract a multifield of strings out of a given DataObject and place its contents inside a std::vector as paths
/// @param dobj The data object to extract the multifield contents from
/// @param list A reference to a std::list<alex::path> to store the multifield contents in
/// @todo  implement a funcall wrapper for this extractData call.
template<>
std::list<Neutron::Path>
extractData<std::list<Neutron::Path>>(Environment& env, Value* dobj);

/// Extract a multifield of strings out of a given DataObject and place its contents inside a std::vector
/// @param dobj The data object to extract the multifield contents from
/// @param list A pointer to a std::vector<string> to store the multifield contents in
template<>
std::vector<std::string>
extractData<std::vector<std::string>>(Environment& env, Value* dobj);



/// Extract the string value out of a DataObject and place it in a provided field
/// @param dobj The data object to extract the string value from
/// @param value a reference to an string value to be updated
template<>
std::string
extractData<std::string>(Environment& env, Value* dobj);

/// Extract the value out of a DataObject and convert it to an Neutron::Path.
/// @param dobj The data object to extract the string value from
/// @param value a reference to an NeutronPath to store in
template<>
Neutron::Path
extractData(Environment& env, Value* dobj);

template<>
std::set<std::string>
extractData<std::set<std::string>>(Environment& env, Value* dobj);

template<>
std::set<Neutron::Path>
extractData<std::set<Neutron::Path>>(Environment& env, Value* dobj);

/**
 * A default discard function used by external addresses that will be destroyed when going out of
 * scope within CLIPS; USE nullptr IF YOU DON'T WANT CLIPS TO DESTROY YOUR EXTERNAL ADDRESS!
 * @tparam T The type contained within the external address that will be destroyed
 * @param ptr The raw environment that this external address was installed into
 * @param thingToDelete the object to be deleted
 * @return Boolean value signifying if destruction was successful, will return false if the pointer is not valid
 */
template<typename T>
bool defaultDiscardFunction(RawEnvironment* ptr, void* thingToDelete)
{
    // this will be a legit pail file
    if (!thingToDelete) {
        return false;
    } else {
        auto ptr = (T*)thingToDelete;
        delete ptr;
        return true;
    }
}

/**
 * Convert the contents of the multifield into a collection of the given type
 */
template<typename T, std::enable_if_t<std::is_same_v<typename T::value_type, typename T::value_type>, int> = 0 /* do not allow types which do not have a value_type field in */>
void
extractData(Environment& env, Value* mf, T& container) 
{
    if (!isMultifield(mf)) {
        throw Neutron::Exception(__HERE__, "Not a multifield!");
    }
    using K = std::decay_t<typename T::value_type>;
    for (size_t index = 0; index < mf->multifieldValue->length; ++index) {
        // we get a UDFValue out
        if (auto& curr = mf->multifieldValue->contents[index]; !isExternalAddress(curr)) {
            container.emplace_back(extractData<K>(env, curr));
        } else {
            if constexpr (std::is_pointer_v<K>) {
                container.emplace_back(env.fromExternalAddress<K>(curr));
            } else {
                container.emplace_back(env.fromExternalAddressAsRef<K>(curr));
            }
        }
    }
}


} // namespace Electron
#endif // end __LibElectron_Environment_h__
